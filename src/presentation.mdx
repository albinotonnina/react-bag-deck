export theme from "theme";
import { Appear, Head, Notes, Image, Code } from "mdx-deck";
import { AbsoluteDiv, RelativeDiv } from "./components";
import "style.css";

<Head>
  <title>--</title>
</Head>

# New React

---

# User Experience

- React.lazy()
- Suspense
- Concurrent Mode

# Developer Experience

- Context API
- Strict Mode
- Profiler
- Hooks

---

### 16.3

# Context API

## A way to pass data through the component tree

<Appear alt>
  <Code className="language-javascript">
    const MyContext = React.createContext(defaultValue);
  </Code>
  <Code className="language-jsx">
    {`<MyContext.Provider value={/* some value */}>`}
  </Code>
  <Code className="language-jsx">
    {`<MyContext.Consumer>
  {value => /* render something based on the context value */}
</MyContext.Consumer>`}
  </Code>
</Appear>

---

<Appear alt showFirst>
  <div>
    <h2>
      Context is designed to share data that can be considered “global” for a
      tree of React components.
    </h2>
    Eg user data, theme, or preferred language.
  </div>
  <div>
    <h2>
      Context is primarily used when some data needs to be accessible by{" "}
      <span style={{ color: "yellow" }}>many</span> components at different
      nesting levels.
    </h2>
    Apply it sparingly because it makes component reuse more difficult.
  </div>
  <div>
    <h2>
      If you only want to avoid passing some props through many levels,
      <span style={{ color: "yellow" }}>component composition</span> is often a simpler
      solution than context.
    </h2>
  </div>
</Appear>

---

### 16.3

# React Strict Mode

## Prepare your code for Concurrent Mode

---

```jsx
import React from "react";

function ExampleApplication() {
  return (
    <div>
      <Header />
      <React.StrictMode>
        <div>
          <ComponentOne />
          <ComponentTwo />
        </div>
      </React.StrictMode>
      <Footer />
    </div>
  );
}
```

---

### 16.5

# Scheduler (experimental)

## Priority queue scheduling system for React

---

<Appear alt showFirst>
  <p>
    An important feature of async rendering in React is the ability to schedule
    updates at different priorities. It's a bit difficult to explain all the
    nuances succinctly, but here's my attempt to squeeze this into two images:
  </p>
  <Image size="50%" src="images/scheduler_1.jpg" />
  <Image size="50%" src="images/scheduler_2.jpg" />
  <p>React team is working with Chrome team to standardize scheduling.</p>
</Appear>

---

### 16.5

# Profiler

---

A browser devtool for profiling duration of React component commit to the DOM.

You can still see the wall time (elapsed real time) but it’s more about duration spent on a component.

You can still profile using browser’s built-in profiler but with React’s Time Slicing and Error Boundaries, it’s hard to stitch together the time React spent on a “component”.

The profiler aims to provide an easier view on component’s commit time.

Basing the profiler on “commit” helps you focus on performance of React components you created, not that of React core or the browser.

---

<Image size="50%" src="images/profiler.png" />

---

### 16.6

# React.lazy()

## render a dynamic import as a regular component.

---

<Appear alt showFirst>
  <div>
    <h2>Before</h2>
    <Code className="language-jsx">{`import OtherComponent from './OtherComponent';}
    
function MyComponent() {
  return (
    <div>
      <OtherComponent />
    </div>
  );
}`}</Code>
  </div>
  <div>
    <h2>After</h2>
    <Code className="language-jsx">{`const OtherComponent = React.lazy(() => import('./OtherComponent'));
  
function MyComponent() {
  return (
    <div>
      <OtherComponent />
    </div>
  );
}`}</Code>

  </div>

<div>
  <h2>With Suspense</h2>
  <Code className="language-jsx">{`const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));
function MyComponent() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <section>
            <OtherComponent />
            <AnotherComponent />
          </section>
        </Suspense>
      </div>
    );
}`}</Code>
</div>

</Appear>

---

### @next

# Hooks

## Extract non-render logic into smaller chunks and share them across function components.

---

```jsx
import { useState } from "react";

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

---

### Hooks let you always use functions instead of having to constantly switch between functions, classes, higher-order components, and render props.

---

### Since Hooks are regular JavaScript functions, you can combine built-in Hooks provided by React into your own “custom Hooks”

```jsx
function MyResponsiveComponent() {
  const width = useWindowWidth(); // Our custom Hook
  return <p>Window width is {width}</p>;
}
```

---

```jsx
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  });

  return width;
}
```

---

## Basic Hooks

- useState
- useEffect
- useContext

## Additional Hooks

- useReducer
- useCallback
- useMemo
- useRef
- useImperativeMethods
- useLayoutEffect

---

### Using hooks results in a simpler API & smaller/readable code base.

<video width="35%" height="50%" controls>
  <source src="images/hooks.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

---

## Long term goal with Hooks

- Replace componentDidMount, componentDidUpdate, and componentWillUnmount with useEffect
- make classes obsolete

---

### 16.x Q2-2019

# Concurrent Mode

---

### 16.x mid-2019

# Suspense for data-fetching

---
