export theme from "theme";
import { Appear, Head, Notes, Image, Code } from "mdx-deck";
import {
  AbsoluteDiv,
  RelativeDiv,
  Title2Left,
  FlexItem,
  FlexContainer,
  Scroller
} from "./components";
import "style.css";

<Head>
  <title>--</title>
</Head>

# New React

---

## The longer term vision...

- Replace componentDidMount, componentDidUpdate, and componentWillUnmount with Hooks
- Every component import is dynamic
- Make classes kinda obsolete
- Pendulum swing back to SSR with Suspense
- More framework-y with code splitting APIs (React.lazy)

---

<Title2Left>User Experience</Title2Left>

- React.lazy()
- Suspense
- Concurrent Mode

---

<Title2Left>Developer Experience</Title2Left>

- Context API
- Strict Mode
- Profiler
- Hooks

---

### react@16.3

# Context API

## A way to pass data through the component tree

<Appear alt>
  <Code className="language-javascript">
    const MyContext = React.createContext(defaultValue);
  </Code>
  <Code className="language-jsx">
    {`<MyContext.Provider value={/* some value */}>`}
  </Code>
  <Code className="language-jsx">
    {`<MyContext.Consumer>
  {value => /* render something based on the context value */}
</MyContext.Consumer>`}
  </Code>
</Appear>

---

<Appear alt showFirst>
  <div>
    <h2>
      Context is designed to share data that can be considered “global” for a
      tree of React components.
    </h2>
    Eg user data, theme, or preferred language.
  </div>
  <div>
    <h2>
      Context is primarily used when some data needs to be accessible by{" "}
      <span style={{ color: "yellow" }}>many</span> components at different
      nesting levels.
    </h2>
    Apply it sparingly because it makes component reuse more difficult.
  </div>
  <div>
    <h2>
      If you only want to avoid passing some props through many levels,
      <span style={{ color: "yellow" }}>component composition</span> is often a simpler
      solution than context.
    </h2>
  </div>
</Appear>

---

### react@16.3

# React Strict Mode

## Prepare your code for Concurrent Mode
---



```jsx
import React from "react";

function ExampleApplication() {
  return (
    <div>
      <Header />
      <React.StrictMode>
        <div>
          <ComponentOne />
          <ComponentTwo />
        </div>
      </React.StrictMode>
      <Footer />
    </div>
  );
}
```

---

what it check for


---

### react@16.5

# Scheduler (experimental)

## Priority queue scheduling system for React

---

<Image size="50%" src="images/scheduler.png" />

---

<Appear alt showFirst>
  <p>
    An important feature of async rendering in React is the ability to schedule
    updates at different priorities. It's a bit difficult to explain all the
    nuances succinctly, but here's my attempt to squeeze this into two images:
  </p>
  <p>React team is working with Chrome team to standardize scheduling.</p>
</Appear>

---

### react@16.5

# Profiler

---

A browser devtool for profiling duration of React component commit to the DOM.

You can still see the wall time (elapsed real time) but it’s more about duration spent on a component.

You can still profile using browser’s built-in profiler but with React’s Time Slicing and Error Boundaries, it’s hard to stitch together the time React spent on a “component”.

The profiler aims to provide an easier view on component’s commit time.

Basing the profiler on “commit” helps you focus on performance of React components you created, not that of React core or the browser.

---

<Image size="50%" src="images/profiler.png" />

---

### react@16.6

# React.lazy()

## render a dynamic import as a regular component.

---

<Appear alt showFirst>
  <div>
    <h2>Before</h2>
    <Code className="language-jsx">{`import OtherComponent from './OtherComponent';}
    
function MyComponent() {
  return (
    <div>
      <OtherComponent />
    </div>
  );
}`}</Code>
  </div>
  <div>
    <h2>After</h2>
    <Code className="language-jsx">{`const OtherComponent = React.lazy(() => import('./OtherComponent'));
  
function MyComponent() {
  return (
    <div>
      <OtherComponent />
    </div>
  );
}`}</Code>

  </div>

<div>
  <h2>With Suspense</h2>
  <Code className="language-jsx">{`const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));
function MyComponent() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <section>
            <OtherComponent />
            <AnotherComponent />
          </section>
        </Suspense>
      </div>
    );
}`}</Code>
</div>

</Appear>

---

### react@next

# Hooks

## Extract non-render logic into smaller chunks and share them across function components.

---

```jsx
import { useState } from "react";

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

---

### Hooks let you always use functions instead of having to constantly switch between functions, classes, higher-order components, and render props.

---

### Since Hooks are regular JavaScript functions, you can combine built-in Hooks provided by React into your own “custom Hooks”

```jsx
function MyResponsiveComponent() {
  const width = useWindowWidth(); // Our custom Hook
  return <p>Window width is {width}</p>;
}
```

---

```jsx
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  });

  return width;
}
```

---

<FlexContainer>
  <FlexItem>
    <Title2Left>Basic Hooks</Title2Left>
<ul>
  <li className="left">useState</li>
  <li className="left">useEffect</li>
  <li className="left">useContext</li>
</ul>
  </FlexItem>

  <FlexItem>
  <Title2Left>Additional Hooks</Title2Left>

<ul>
<li className="left">useReducer</li>
<li className="left">useCallback</li>
<li className="left">useMemo</li>
<li className="left">useRef</li>
<li className="left">useImperativeMethods</li>
<li className="left">useLayoutEffect</li>
  </ul>
  </FlexItem>

  </FlexContainer>

---

### Using hooks results in a simpler API & smaller/readable code base.

<video width="35%" height="50%" controls>
  <source src="images/hooks.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

---

### react@16.x Q2-2019

# Concurrent Mode

## Smooth high performance UX.
---

Thanks to the Fiber architecture, React renders parts of the tree while code and data for other parts is *still loading*, and then continue as they arrive.

---

<Appear alt showFirst>
  <Image size="50%" src="images/scheduler_1.jpg" />

  <Image size="50%" src="images/scheduler_2.jpg" />
</Appear>


---

Time Slicing

---

# Concurrent mode is testable

## You will be able to test just like a synchronous code

## React team plans to provide a helper method to enable specific current mode testing in libraries/frameworks.

---

### react@16.x mid-2019

# Suspense for data-fetching

## Treat Asynchronous data as if it was synchronous/local data

---

<Scroller>
  <Code className="language-jsx">
    {`
    class Item extends React.Component {
 
      constructor() {
        super()
        this.state = {data: null}
      }
 
      componentDidMount() {
        this.getLatestData(this.props.id)
      }
 
      componentDidUpdate(prevProps) {
        if(prevProps.id !== this.props.id) {
          this.getLatestData(this.props.id)
        }
      }
 
      async getLatestData(id) {
        const review = await fetchAPI(
          \`reviews/\${id}\`,
        )
        this.setState({data: review})
      }
 
      render() {
        const data = this.state.data
        if (data === null) {
          return <Spinner />
        }
        return (
          <div>
            <quote>
              <p>{data.content}</p>
            </quote>
          </div>
        )
      }
 
    }`}

  </Code>
</Scroller>

---

<Scroller>
  <Code className="language-jsx">
    {`
<div>
  <Suspense maxDuration={1000} fallback={<Spinner size="medium" />}>
    <section>
      <div>
        <Item id={someID} />
      </div>
    <section>
  </Suspense>
</div>
    `}

  </Code>
</Scroller>

---

realDuration = Math.min(maxDuration, currentDefaultDuration)

currentDefaultDuration depends on where setState is called. By default (e.g. in AJAX callback) it’s 5 seconds. Inside “intentional” events like click, it’s pretty short (I think 100ms in prod). And you can adjust it.

---

<Scroller>
  <Code className="language-jsx">
    {`import { createResource } from 'react-cache'
 
const APIResource = createResource(path => fetchAPI(path))
 
function Item(props){
  
  const data = APIResource.read(
    \`/reviews/\${props.id}\`
  )
 
 return(
  <div>
    <quote>
      <p>{data.content}</p>
    </quote>
  </div>
 )
}`}

  </Code>
</Scroller>

---

react-cache is a reference React Suspense cache implementation maintained by the React team.
